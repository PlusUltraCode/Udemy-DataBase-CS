# 섹션4. 데이터베이스 인덱싱

## 22. 인덱스 시작하기

### Postgres의 기본 적인 명령어

```sql
# 스키마 정보 출력
\d 테이블 이름

explain analyze select id from employees where id = 2000;
```

### Index 유무 확인

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2010.png)

id가 2000인 튜플을 찾기 위해 Postgres는 Index Scan을 통해 찾게 된다. 이 정보에는 Heap Fetches 또한 볼 수 있다.

ID는 Index를 통해 매우 빠르게 스캔이 가능하지만 ID 대신 name을 조회할 경우 어떻게 될까?

```sql
explain analyze select id from employees where name = 'Zs';
```

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2011.png)

Name에는 인덱스가 없기 때문에 Parallel Seq Scan(순차적 스캔)을 통해 name이 ‘Zs’인 튜플을 찾게 된다.

이보다 더 느린 쿼리는 LIKE를 사용한 쿼리이다. LIKE 사용 시, 해당 조건에 맞는지 문자열을 모두 확인해야하기 때문이다.

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2012.png)

### 인덱스 적용하기

아까전에 살펴본 name 칼럼에 대해 인덱스를 추가해보자.

```sql
create index employees_name on employees(name);
```

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2013.png)

아까와 비교해서 Execution Time이 89ms정도 빨라졌다. 또한 자세히보면 Bitmap Heap Scan을 통해 스캔이 진행된다.

<aside>
💡

### Expression의 인덱싱

인덱스는 단일값에 대해서만 적용이 가능하다. 그러면 Like와 같은 표현식을 사용할 경우 name에 대한 인덱스의 효과를 볼 수 있을까?

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2014.png)

전혀 인덱스의 효과를 보지 못하고, Parallel Seq Scan을 진행하기에 수행시간은 똑같다.

인덱스는 단일 값에 대해서만 적용됨을 명심하자.

</aside>

<aside>
💡

인덱스를 사용할 지에 대해선 데이터베이스의 `플래너`가 결정한다.

</aside>

# 🤔궁금한점

1. 문자열의 경우 B-Tree에선 어떻게 저장되는가? 단순히 사전순으로 정렬되는가?
2. Parallel Seq Scan과 Seq Scan 차이

## 23. Explain으로 SQL 쿼리 플래너와 옵티마이저 이해하기

### 테이블 셋팅

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2015.png)

### 쿼리 테스트 #1

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2016.png)

- cost의 첫번째 : 첫 번째 페이지를 가져오는데 걸린 시간 (ms)
- cost의 두번째 : 총 걸린 시간
    - 위 계산은 단지 옵티마이저에 의한 추정에 불과
    

위 쿼리의 경우 즉시 테이블로 이동하여 첫 번째 행을 가져오기 때문에 비용이 들지 않는다. 따라서, limit 1을 사용 시 매우 빠르게 데이터를 가져올 수 있다.

### 쿼리 테스트 #2

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2017.png)

인덱스로 인해 미리 정렬되어 있기 때문에 상대적으로 작업 시간이 매우 적게 든다.

### 쿼리 테스트 #3

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2018.png)

name에 대한 인덱스가 없기 때문에 느려야 하지만, 이상하게 빠르게 나온다.

### 쿼리 테스트 #4

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2019.png)

### 쿼리 테스트 #5

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2020.png)

## 24. 비트맵 인덱스 스캔 & 인덱스 스캔 & 테이블 스캔

```sql
explain select name from grades where id < 100;
```

```sql
Index Scan using grades_pkey on grades (cost=0.43..391.13 rows=98 width=4)
	Index Cond: (id < 100)
(2 rows)
```

B 트리에서 이 작업을 빠르게 수행

Postgres는 몇 개의 행이 반환될지에 대한 정보를 알고 있음

찾는 각각의 값에 대해 그 행이 존재하는 페이지를 찾고 힙으로 돌아가서 페이지를 가져온 후 해당 값을 추출

이런 방법을 랜덤 엑세스라고 한다.

이런 랜덤 엑세스는 행이 많을 경우 느려질 수 있다

이번엔 id > 100에 대한 분석

```sql
explain select name from grades where id > 100;
```

```sql
Seq Scan using grades_pkey on grades (cost=0.00..134265.34 rows=5000248 width=4)
	Index Cond: (id > 100)

```

테이블로 직접 이동하여 순차 스캔을 사용한다. 이 경우 랜덤 엑세스 보다 매우 적은 코스트를 가지기 때문에 순차 탐색을 진행한다.

따라서, 행이 얼마나 많은가에 따라 인덱스 스캔과 순차 스캔이 결정되는 것으로 보인다. 

(행이 적을 경우 인덱스 스캔, 행이 많을 경우 순차 스캔)

근데 이런 식으로 행이 애매할 경우에 비트맵 스캔을 실시한다. 비트맵 스캔은 인덱스 스캔에서 발생하는 랜덤 엑세스를 방지하면서 인덱스의 성능을 어느 정도 가져온다. 또한 경직된 BTree 대신 비트맵을 사용하여 효율이 더 좋다.

사실 Postgres는 비트맵 인덱스 스캔을 진행한다. (g에 대한 인덱스가 있다고 가정)

```sql
explain select name from grades where g > 95;
```

```sql
Bitmap Heap Scan using grades_pkey on grades (cost=3859.77..110758.53 rows=205850 width=4)
	Recheck Cond: (g > 95)
	-> Bitmap Index Scan on g(cost=0.00..3808.31 rows=205850 width=0)
		Index Cond: (g > 95)
```

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2021.png)

1. 비트맵 인덱스 스캔으로 인덱스를 가져와 비트맵을 만든다.
    - 인덱스 스캔을 하고 바로 테이블을 방문하지 않고 비트맵의 비트를 설정한다.
2. 비트맵 힙 스캔으로 해당 비트맵을 읽고 메모리에서 데이터를 가져온다.
    - 비트맵으로 페이지 수를 알고 있어서 한 번에 힙에서 모든 페이지를 가져온다.
    - Postgres는 가져온 페이지의 데이터에서 조건을 만족하지 않는 것을 제거한다.
        - 이를 Recheck 과정이라고 한다.

가정 : ID와 G에 모두 인덱스가 있다.

```sql
explain select name from grades where g > 95 and id < 10000;
```

```sql
Bitmap Heap Scan using grades_pkey on grades (cost=3859.77..5479.62 rows=394 width=4)
	Recheck Cond: ((id < 10000) AND (g > 95))
	-> Bitmap Index Scan on grades_pkey (cost=0.00..180.21 rows=9570 width=0)
		Index Cond: (id < 10000)
	-> Bitmap Index Scan on g (cost=0.00..3808.31 rows=205850 width=0)
		Index Cond: (g > 95)
```

![image.png](%E1%84%8B%E1%85%B2%E1%84%83%E1%85%A6%E1%84%86%E1%85%B5%20%E1%84%83%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%87%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%2016564b4a4ab480ec8556dff4ee610feb/image%2022.png)

인덱스 A와 B에 모두 일치하는 비트만을 가져온다.

<aside>
📌

페이지를 가져오면 바로 데이터 접근이 가능하다. 그 이유는 공유 메모리에 데이터가 있기 때문

</aside>

## 25. 식별자, 비식별자 열 데이터베이스 인덱싱

```sql

```
